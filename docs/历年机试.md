# Previous Coding Tests

## 2019北大信科研究生上机测试

### A:护林员盖房子

```c++
/*
 * A:护林员盖房子
查看 提交 统计 提问
总时间限制: 1000ms 内存限制: 65536kB
描述
在一片保护林中，护林员想要盖一座房子来居住，但他不能砍伐任何树木。
现在请你帮他计算：保护林中所能用来盖房子的矩形空地的最大面积。
输入
保护林用一个二维矩阵来表示，长宽都不超过20（即<=20）。
第一行是两个正整数m,n，表示矩阵有m行n列。
然后是m行，每行n个整数，用1代表树木，用0表示空地。
输出
一个正整数，表示保护林中能用来盖房子的最大矩形空地面积。
样例输入
4 5
0 1 0 1 1
0 1 0 0 1
0 0 0 0 0
0 1 1 0 1
样例输出
5
提示
子矩阵边长可以为1，也就是说：
0 0 0 0 0
依然是一个可以盖房子的子矩阵。
来源
2017医学部计算概论-期末考试-申博
 */

#include <iostream>

using namespace std;

const int maxn = 25;
int nums[maxn][maxn];

// 扫描线法 求最大空地面积
// 使用三个数组
// h[i, j] 表示点 (i, j) 对应的悬线长度
// left[i, j] 表示点 (i, j) 对应的悬线左边界
// right[i, j] 表示点 (i, j) 对应的悬线右边界

// 从上向下扫描，从左到右计算 left 数组，从右到左计算 right 数组，并更新答案
// 在实现中，数组降维以节约空间

int h[maxn], l[maxn], r[maxn];
int lb, rb;  // 与当前点最近的障碍点
int ans = 0;

int main() {
    int m, n;
    cin >> m >> n;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            cin >> nums[i][j];
        }
    }

    for (int j = 0; j < n; j++) {
        h[j] = 0;
        // 初始化每个点左右边界 只要在[0, n-1]之外即可
        l[j] = -1; 
        r[j] = n;
    }

    for (int i = 0; i < m; i++) {
        lb = -1;
        rb = n;
        for (int j = 0; j < n; j++) { // 从左到右扫描
            if (nums[i][j] == 1) {  // 该点是障碍
                h[j] = 0;
                l[j] = -1;
                lb = j;
            } else {  // 该点是空地
                h[j]++;
                l[j] = max(l[j], lb + 1); 
                // 此处的l[j] 实际上是l[i-1,j] 上一行的该点空地左边界 lb+1是当前行的左边界 
            }
        }
        for (int j = n - 1; j >= 0; j--) { // 从右到左扫描
            if (nums[i][j] == 1) {  // 该点是障碍
                r[j] = n;
                rb = j;
            } else {  // 该点是空地
                r[j] = min(r[j], rb - 1);
                ans = max(ans, h[j] * (r[j] - l[j] + 1));
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```



## 2018年北京大学软件工程学科夏令营上机练习

<https://blog.csdn.net/qq_34446253/article/details/51987082>

## 2018北京大学计算机学科夏令营上机考试

### E 重要逆序对

```
E:重要逆序对
查看 提交 统计 提问
总时间限制: 10000ms 单个测试点时间限制: 1000ms 内存限制: 65536kB
描述
给定N个数的序列a1,a2,...aN，定义一个数对(ai, aj)为“重要逆序对”的充要条件为 i < j 且 ai > 2aj。求给定序列中“重要逆序对”的个数。
输入
第一行为序列中数字的个数N（1 ≤ N ≤ 200000）。
第二行为序列a1, a2 ... aN(0 ≤a ≤ 10000000)，由空格分开。
输出
输出一个整数，为给序列中“重要逆序对”的个数。
样例输入
10
0 9 8 7 6 5 4 3 2 1
样例输出
16
提示
如果使用printf输出long long类型，请用%lld
数据范围
对于40%的数据，有N ≤ 1000。
```



```c++
// 计算重要逆序对只需要对归并排序解法做简单的更改，但排序和求逆序对数需要分离

#include <bits/stdc++.h>

using namespace std;

long long ans; // 重要逆序对的数量，题目暗示使用 long long

/**
 * 归并左右两数组
 *
 * @param nums
 * @param left
 * @param mid
 * @param right
 */
void merge(vector<int> &nums, int left, int mid, int right) {
    // 创建临时数组
    vector<int> L;
    vector<int> R;

    for (int i = left; i <= mid; i++)
        L.push_back(nums[i]);
    for (int j = mid + 1; j <= right; j++)
        R.push_back(nums[j]);

    int i = 0, j = 0, k = left;
    int l1 = mid - left + 1, l2 = right - mid;
    // 合并两数组，注意排序的规则在本题中：不是单纯地比较原始数组中两数字的大小

    while (i < l1 && j < l2) {
        if (L[i] <= 2 * R[j]){
            i++;
        } else{
            j++;
            ans += (l1 - i);
        }
    }
    i = 0, j = 0;
    while (i < l1 && j < l2) {
        if (L[i] <= R[j])
            nums[k++] = L[i++];
        else
            nums[k++] = R[j++];

    }

    while (i < l1) nums[k++] = L[i++];
    while (j < l2) nums[k++] = R[j++];
}

/**
 * 递归实现的归并排序
 *
 * @param nums
 * @param left
 * @param right
 */
void mergeSort(vector<int> &nums, int left, int right) {
    if (left < right) { // 注意判断
        int mid = left + (right - left) / 2;
        mergeSort(nums, left, mid); // 闭区间[left, mid]
        mergeSort(nums, mid + 1, right); // 闭区间[mid + 1, right]
        merge(nums, left, mid, right);
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    int n;
    vector<int> nums;
    cin >> n;
    int num;
    for (int i = 0; i < n; i++) {
        cin >> num;
        nums.push_back(num);
    }

    mergeSort(nums, 0, nums.size() - 1);

    cout << ans;
    return 0;
}
```

## 2018年清华大学软件学院夏令营机试

### 第1题 回文数

>   输入只有一行，包含两个整数a,b，要求输出[a,b]内所有的回文数，a,b<10^6

```c++
#include <bits/stdc++.h>

using namespace std;

int num[10]; // 数组低位存数字低位
bool check(int x) {
    // sprintf 可能略快于 stringstream，但此处使用手动转换，程序性能优势明显
    int len = 0;
    while (x) {
        num[len++] = x % 10;
        x /= 10;
    }
    int i = 0, j = len - 1;
    while (i < j) {
        if (num[i++] != num[j--])
            return false;
    }
    return true;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    int a, b;
    cin >> a >> b;
    if (a > b)
        swap(a, b);

    for (int i = a; i <= b; i++) {
        if (check(i))
            cout << i << endl;
    }

    return 0;
}
```

### 第2题 上凸函数

>   在一个上凸函数上均匀采样得到{f(i)|i=1,2…N},有M次询问，每次询问输入两个整数a,b,求{f(i)-a*i-b|i=1,2…N}的最大值。
>
>   输入：第一行,N和M, 其中N,M<5e5
>
>    然后N行，按顺序输入f(i)
>
>    然后M行，每行两个整数 a,b

##### 思路

-   运用性质：`f[i]-a*i-b`最大值处的f函数的切线斜率等于a
-   二分查找f'[i] = diff[i]（离散差分数组）中最小的大于等于a的数的坐标i（可能出现连续多个diff[i]相等的情况，取边缘）
-   f[i] - a * i - b 取最小值的坐标在 [i - 1, i + 1] 的范围内
    -   注意1：i在diff数组两头的情况
    -   注意2：C++中f[i]的下标从0开始，但题目中f(i)下标从1开始

```c++
#include<bits/stdc++.h>

using namespace std;

const int maxn = 5e5 + 5, inf = 0x3f3f3f3f;
int n, m;
int f[maxn], diff[maxn]; // diff: f的差分，长度为n-1, 由于f是上凸函数，diff是递减函数

int binary_search(int a) {  // 在diff[i]中搜索最小的大于等于a的数的坐标
    int l = 0, r = n - 2, mid;
    if (diff[0] < a) // diff 递减，之后不可能搜索到大于等于a
        return 0;
    else if (diff[n - 2] > a)
        return n - 2;
    while (true) {
        if (l == r)
            return l;
        else if (l + 1 == r && diff[r] < a && diff[l] >= a)
            return r;

        mid = (l + r) / 2;
        if (diff[mid] >= a) // 搜索右区间
            l = mid;
        else if (diff[mid] < a) // 搜索左区间
            r = mid;
    }
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    int i = 0, a, b, ans1, ans2, ans3;
    cin >> n >> m; // n是函数点的数量，m是搜索次数
    for (i = 0; i < n; i++) {
        cin >> f[i];
        if (i > 0)
            diff[i - 1] = f[i] - f[i - 1]; // 离散差分近似切线斜率
    }
    // 注意下标范围
    // f[0...(n-1)]
    // diff[0...(n-2)]

    while (m--) {
        cin >> a >> b;
        i = binary_search(a);
        if (i == 0) {
            ans1 = f[0] - a - b;
            ans2 = f[1] - a * 2 - b;
            ans3 = f[2] - a * 3 - b;
        } else if (i == n - 2) {
            ans1 = f[n - 1] - a * (n - 1 + 1) - b;
            ans2 = f[n - 2] - a * (n - 2 + 1) - b;
            ans3 = f[n - 3] - a * (n - 3 + 1) - b;
        } else {
            ans1 = f[i] - a * (i + 1) - b;
            ans2 = f[i - 1] - a * (i - 1 + 1) - b;
            ans3 = f[i + 1] - a * (i + 1 + 1) - b;
        }
        ans1 = max(ans1, max(ans2, ans3));
        printf("%d\n", ans1);
    }
    return 0;
}
```

### 第3题 质因子

>   给定N个质数，构成集合S，设集合T为由质因子全部在S中的整数构成的集合，求T中第k小的数，其中1<=N<=100,1<=k<=1e5,输出保证在int的范围之内
>
>   输入：第一行 N，k
>
>    第二行 N个质数

```c++ tab="丑数思路"
// 参考 LeetCode 264. Ugly Number II 复习，但本题的质数数量更多

#include <bits/stdc++.h>

using namespace std;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);

    int n, k;
    int t;
    cin >> n >> k;

    vector<int> primes; // 质数集合
    vector<int> dp(k + 1); // dp[i] 是第i个符合条件的数
    vector<int> pointer(n, 0); // 质数的指针

    for (int i = 0; i < n; i++) {
        cin >> t;
        primes.push_back(t);
    }

    sort(primes.begin(), primes.end());
    dp[0] = 1;
    for (int i = 1; i <= k; i++) {
        // 首先找到下一个符合要求的数，然后向后移动指针
        for (int j = 0; j < n; j++) {
            if (dp[i] == 0)
                dp[i] = dp[pointer[j]] * primes[j];
            else dp[i] = min(dp[i], dp[pointer[j]] * primes[j]);
        }
        cout << "dp[" << i << "]: " << dp[i] << endl;
        for (int j = 0; j < n; j++) {
            if (dp[i] == dp[pointer[j]] * primes[j])
                pointer[j]++;
        }
    }
    cout << dp[k];
    return 0;
}
```

```c++ tab="优先队列思路"
#include <bits/stdc++.h>
using namespace std;
typedef long long  ll;

int n,k,s[110];
priority_queue<int,vector<int> ,greater<int> >que;
int solve(){
    while(que.size()) que.pop();
    for(int i=0;i<n;++i) que.push(s[i]);
    int cnt=0,x,last;
    while(cnt<k){
        x=que.top(); que.pop();
        if(x==last) continue;
        ++cnt; 
        last=x;
        for(int i=0;i<n;++i) que.push(s[i]*x);
    }
    return last;
}
int main(){
    while(scanf("%d%d",&n,&k)==2){
        for(int i=0;i<n;++i) scanf("%d",&s[i]);
        printf("%d\n",solve());
    }
    return 0;
}
```

### 第四题 堆优化双向Dijkstra

>   编号为1到N的N个城市间有M条铁路，通过每条铁路花费时间T_i,为了减少从城市1到N的时间，现在决定将其中一条铁路改建成高铁，改建后通过该条铁路的时间将减半（向下取整数），求改建哪条铁路可以使得改建后从城市1到城市N的时间最短
>
>   输入：第一行N和M 接下来M行，每行A_i, B_i, T_i分别是第i条铁路的起点和终点，以及时间 输出：改建的铁路编号以及改建后从1到N的时间
>
>   注意：铁路是双向的，保证解唯一
>
>   80%数据N,M<5000,100%数据N,M<1000000

#### 思路

-   从节点1和节点n分别做一次Dijkstra求从节点1出发的到每个点的最短路（保存在d1里）和从节点n出发到每个点的最短路（保存在d2里）。然后遍历m条边，建高铁后从节点1到节点n的最短路为`min(d1[u] + d2[v] + len[u,v])`
-   d1[u]的路径有可能包含边(u,v)，d2[v]的路径也有可能包含边(u,v)，
-   因此最短路的表达式应 `min(min(d1[u] + d2[v], d1[v] + d2[u]) + len[u,v])`
-   数据规模显示是稀疏图，因此用堆优化的Dijkstra，相应的采用邻接表的数据结构（本来邻接矩阵就会爆内存——vs显示数组过大）存储路网信息，复杂度为O(mlogn + m) = O(mlogn)

```c++ tab=&quot;解法一&quot;
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<string>
#include<vector>
#include<stack>
#include<queue>
#include<set>
#include<map>
#include<algorithm>
#include<functional>
#include<sstream>
#include<functional>
using namespace std;
typedef long long  ll;
const int maxn=1e6+10,inf=10000000;
int to1[maxn],ton[maxn],n,m;
struct biedge{
    int u,v,t;
} biedges[maxn];
struct edge{
    int v,t;
    edge(int v=0,int t=0){
        this->v=v; 
        this->t=t;
    }
    bool operator<(const edge& b)const {return t>b.t;}
};
vector<edge> edges[maxn];
priority_queue<edge> que;

void  dij(int s,int *d){
    fill(d,d+n+1,inf);
    while(que.size()) que.pop();
    d[s]=0;
    que.push(edge(s,0));
    while(que.size()){
        int u=que.top().v,t=que.top().t;
        que.pop();
        if(d[u]!=t) continue;
        for(int i=0;i<edges[u].size();++i){
            int v=edges[u][i].v;
            if(d[u]+edges[u][i].t<d[v]){
                d[v]=d[u]+edges[u][i].t;
                que.push(edge(v,d[v]));
            }
        }
    }
}

int main(){
    while(scanf("%d%d",&n,&m)==2){
        for(int i=1;i<=m;++i){
            int u,v,t;  scanf("%d%d%d",&u,&v,&t);
            biedges[i].u=u; 
            biedges[i].v=v; 
            biedges[i].t=t; 
            edges[u].push_back(edge(v,t));
            edges[v].push_back(edge(u,t));
        }
        dij(1,to1);
        dij(n,ton);
        int res=inf,idx;
        for(int i=1;i<=m;++i){
            int u=biedges[i].u,v=biedges[i].v;
            int tmp=to1[u]+ton[v]+biedges[i].t/2;
            if(tmp<res){
                res=tmp; 
                idx=i;
            }
        }
        printf("%d %d\n",idx,res);
    }
    return 0;
}
```

```c++ tab=&quot;解法2&quot;
// 用堆优化的Dijkstra算法算两遍，分别从源点和汇点开始算，
// 算得d1数组记录所有点到源点的距离，d2数组记录所有点到汇点的距离
// 遍历m条边，ans = min(min(d1[u] + d2[v], d1[v] + d2[u]) + len[u,v])

#include<cstdio>
#include<queue>
#include<vector>
#include<cstring>

const int NMAX = 1000005, INF = 0x3f3f3f3f;

struct toEdge {
    int v,t;

    toEdge(int vv, int tt): v(vv), t(tt) {}
    toEdge(void) {}
};

struct cmp {
    bool operator() (const toEdge & a, const toEdge & b)
    {
        return a.t > b.t;
    }
};

struct Edge {
    int u, v, t;

    Edge(int uu, int vv, int tt): u(uu), v(vv), t(tt) {}
    Edge(void){}
}edges[NMAX];


int n, m;
std::vector<toEdge> E[NMAX];    // 邻接表
int d[NMAX] = {};
int vis[NMAX] = {};
int d1[NMAX] = {};          // 从节点1出发到各点的最短路
int d2[NMAX] = {};          // 从节点2出发到各点的最短路

void dijkstra(int src)      // 用Dijkstra算法求从src出发到各点的最短路
{
    int i, v, t;
    std::priority_queue<toEdge, std::vector<toEdge>, cmp> q;
    memset(vis, 0, sizeof(vis));
    memset(d, 0x3f, sizeof(d));
    vis[src] = 1;
    d[src] = 0;
    for (i = 0; i < E[src].size(); i++)
    {
        q.push(toEdge(E[src].at(i).v, E[src].at(i).t));
    }
    while (!q.empty())
    {
        v = q.top().v;
        while (vis[v])
        {
            q.pop();
            if (q.empty())
            {
                return;
            }
            v = q.top().v;
        }
        vis[v] = 1;
        t = q.top().t;
        d[v] = t;
        for (i = 0; i < E[v].size(); i++)
        {
            if (!vis[E[v].at(i).v] && d[E[v].at(i).v] > E[v].at(i).t + t)
            {
                q.push(toEdge(E[v].at(i).v, E[v].at(i).t + t));
            }
        }
    }
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("xlySE18_04.txt", "r", stdin);
#endif
    scanf("%d%d", &n, &m);
    int i = 0, u, v, t, minv = INF, minid = -1;
    for (i=0; i<m; i++)
    {
        scanf("%d%d%d", &u, &v, &t);
        E[u].push_back(toEdge(v,t));
        E[v].push_back(toEdge(u,t));
        edges[i] = Edge(u,v,t);
    }
    dijkstra(1);
    memcpy(d1, d, sizeof(d));
    dijkstra(n);
    memcpy(d2, d, sizeof(d));
    for (i=0; i<m; i++)
    {
        u = edges[i].u;
        v = edges[i].v;
        t = edges[i].t;
        if (t/2 + d1[u] + d2[v] < minv)         // 取std::min(d1[u] + d2[v], d1[v] + d2[u])
        {
            minv = t/2 + d1[u] + d2[v];
            minid = i + 1;
        }
        else if (t/2 + d1[v] + d2[u] < minv)
        {
            minv = t/2 + d1[v] + d2[u];
            minid = i + 1;
        }
    }
    printf("%d %d", minid, minv);
    return 0;
}
```

## 2018清华软院九推机试

```c++
// 2018清华软院九推机试1 大整数乘法
// 2018清华软院九推机试2 大整数排列

#include <iostream>
#include <sstream>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxlen = 1000;

class BigInteger {
public:
    int d[maxlen]; // 存储大数，数组低位存储大数低位
    int len; // 记录长度

    void clear() {
        memset(d, 0, sizeof(d));
        len = 0;
    }

    BigInteger() {
        clear();
    }

    BigInteger(string str) {
        clear();
        for (int i = str.size() - 1; i >= 0; i--) {
            d[len++] = str[i] - '0';
        }
    }

    string toString() {
        stringstream ss;
        string str;
        for (int i = len - 1; i >= 0; i--) {
            ss << d[i];
        }
        ss >> str;
        return str;
    }

};

BigInteger next_permutation(BigInteger bign) {
    string str = bign.toString();
    if (str.empty() || str.size() == 1) return bign;
    next_permutation(str.begin(), str.end());
    return BigInteger(str);
}

/**
 * 大整数加法
 * 大整数乘法
 * @param a 大整数
 * @param b 大整数
 * @return 大整数 a + b
 */
BigInteger add(BigInteger a, BigInteger b) {
    BigInteger res;
    int carry = 0;
    for (res.len = 0; res.len < max(a.len, b.len); res.len++) {
        int sum = a.d[res.len] + b.d[res.len] + carry;
        res.d[res.len] = sum % 10;
        carry = sum / 10;
    }
    if (carry)
        res.d[res.len++] = carry;
    return res;
}

/**
 * 大整数乘以int
 * @param a 大整数
 * @param b 整数
 * @return 大整数 a * b
 */
BigInteger multiply(BigInteger a, int b) {
    BigInteger res;
    int carry = 0;
    for (res.len = 0; res.len < a.len; ++res.len) {
        int product = a.d[res.len] * b + carry;
        res.d[res.len] = product % 10;
        carry = product / 10;
    }
    if (carry)
        res.d[res.len++] = carry;
    return res;
}

/**
 * 大整数乘法
 * @param a 大整数
 * @param b 大整数
 * @return 大整数 a * b
 */
BigInteger multiply(BigInteger a, BigInteger b) {
    BigInteger res("0");
    for (int j = 0; j < b.len; j++) {
        BigInteger mul = multiply(a, b.d[j]);
        for (int k = 0; k < j; k++) {
            mul = multiply(mul, 10);
        }
        res = add(res, mul);
    }
    return res;
}

int main() {
    string a, b;
    string res;
    while (cin >> a >> b) {
        BigInteger biga(a);
        BigInteger bigb(b);
        res = add(biga, bigb).toString();
        cout << "sum: " << res << endl;
        res = multiply(biga, bigb).toString();
        cout << "product: " << res << endl;
        BigInteger bigc = next_permutation(biga);
        cout << "next_permutation: " << bigc.toString() << endl;
    }
    return 0;
}
```

## 2018清华计算机上机练习

```
【题目描述】
今年，n只思考熊参加了清华大学校园马拉松比赛。马拉松的赛道是环形的，每圈
的长度是A，完成比赛需要跑L圈。
比赛中，甲领先乙很长距离，绕过一圈或多圈后从后面追上了乙的现象叫做“套
圈”。套圈现象非常常见，例如：跑得比谁都快的saffah熊可以套某些熊L-1圈；
ufozgg熊经常进行日常耐力训练，套圈次数和被套圈次数基本持平；而Mulab作为一
只老年熊，则是被套L-1圈的那种。
与人不同的是，思考熊在跑步时都是匀速运动。wyx熊是这次比赛的计时员，他
统计了参赛的n只熊的速度v1， v2，......，vn（其中最大的一个是saffah熊的速度）。现在
wyx熊希望你告诉他，当速度最快的saffah熊到达终点时，场上所有熊中总共发生了
多少次套圈现象。
注意：在saffah熊刚刚到达终点那一刻，如果甲恰好追上了乙，此时也算作甲将乙
套圈。
【输入格式】
从文件running.in中读入数据。
输入的第一行包含2个整数T;C，分别表示这个测试点内数据的组数和这个测试
点的编号。对于所有测试点，保证T = 10。
每组数据的第一行包含3个正整数n;A;L，分别表示思考熊的只数，跑道每圈的长
度和完成比赛所需要的圈数。保证A;L<10^8。
第二行包含n个正整数v1， v2，......，vn，表示每只思考熊的速度。保证这些数互不
相同。
【输出格式】
输出到文件running.out中。
输出T行，分别表示每组数据中，所有熊发生的套圈总次数。
【样例输入】
4 0
2 1000 15
2 5
2 1000 13
9 4
5 1000 10
8 10 2 5 6
5 1000 17
8 10 2 5 7
【样例输出】
9
7
38
61
【数据范围】
n<=10^5,vi<=10^8
【题解】
套圈的圈数只取决于每个人跑了多少圈，所以答案为两两之间的圈数差向下取整
因为有圈数小数部分，所以无法通过前缀和O(n)计算
但是，我们可以把小数部分和整数部分分开做
整数部分用前缀和维护圈数，如果小数部分的差小于0，就再减1
比如一个跑了5.1圈，一个4.9圈，它们整数部分差为5-4=1，但是因为小数部分0.1-0.9<0，所以需要减1
所以需要找出两个数i,j，整数部分i>j，但小数i<j
这就是逆序对裸题了，树状数组就能搞定。
还有一个小优化，因为跑的圈数是 l * vi/ vmax，分母都相同，可以全部去掉转化成整数计算，避免精度误差

https://www.cnblogs.com/qwerfcxs/p/7802638.html
https://blog.csdn.net/qq_40760407/article/details/83514782
```

