



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Looper's personal notes">
      
      
        <link rel="canonical" href="https://looperxx.github.io/My_wiki/Coding Knowledge/">
      
      
        <meta name="author" content="Looper - Xiao Xu">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.2.0">
    
    
      
        <title>重点内容 - Looper's wiki</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.750b69bd.css">
      
      
    
    
      <script src="../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-XXXXXXXX-X", "auto")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#_1" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://looperxx.github.io/My_wiki" title="Looper's wiki" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Looper's wiki
            </span>
            <span class="md-header-nav__topic">
              重点内容
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/looperxx/My_wiki/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    looperxx/My_wiki
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href=".." title="Home" class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../OS/" title="Math & CS Course" class="md-tabs__link">
          Math & CS Course
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../知识网络/" title="Coding" class="md-tabs__link md-tabs__link--active">
          Coding
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../Concepts/" title="ML & DL" class="md-tabs__link">
          ML & DL
        </a>
      
    </li>
  

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../自然语言处理简介/" title="NLP" class="md-tabs__link">
          NLP
        </a>
      
    </li>
  

  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../面经/" title="Interview experience" class="md-tabs__link">
          Interview experience
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../MkDocs_demo/" title="For MkDocs" class="md-tabs__link">
          For MkDocs
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://looperxx.github.io/My_wiki" title="Looper's wiki" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Looper's wiki
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/looperxx/My_wiki/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    looperxx/My_wiki
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Math & CS Course
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Math & CS Course
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../OS/" title="OS" class="md-nav__link">
      OS
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linux/" title="Linux" class="md-nav__link">
      Linux
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Coding
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Coding
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../知识网络/" title="知识网络" class="md-nav__link">
      知识网络
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        重点内容
      </label>
    
    <a href="./" title="重点内容" class="md-nav__link md-nav__link--active">
      重点内容
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" title="基础算法" class="md-nav__link">
    基础算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" title="递归" class="md-nav__link">
    递归
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" title="汉诺塔" class="md-nav__link">
    汉诺塔
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="排序" class="md-nav__link">
    排序
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" title="快排" class="md-nav__link">
    快排
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="堆排" class="md-nav__link">
    堆排
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="拓扑排序" class="md-nav__link">
    拓扑排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" title="查找" class="md-nav__link">
    查找
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" title="二分查找" class="md-nav__link">
    二分查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" title="并查集" class="md-nav__link">
    并查集
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" title="位运算" class="md-nav__link">
    位运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" title="分数表示" class="md-nav__link">
    分数表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" title="字符串" class="md-nav__link">
    字符串
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" title="回文串" class="md-nav__link">
    回文串
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" title="树算法" class="md-nav__link">
    树算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" title="哈夫曼树" class="md-nav__link">
    哈夫曼树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" title="图算法" class="md-nav__link">
    图算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" title="最短路径" class="md-nav__link">
    最短路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" title="最小生成树" class="md-nav__link">
    最小生成树
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim" title="PRIM 算法¶" class="md-nav__link">
    PRIM 算法¶
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" title="KRUSKAL 算法" class="md-nav__link">
    KRUSKAL 算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" title="其他" class="md-nav__link">
    其他
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" title="斐波那契与卡塔兰数" class="md-nav__link">
    斐波那契与卡塔兰数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" title="欧几里得定理" class="md-nav__link">
    欧几里得定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" title="矩阵连乘" class="md-nav__link">
    矩阵连乘
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" title="快速乘法" class="md-nav__link">
    快速乘法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" title="素数" class="md-nav__link">
    素数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" title="逆序对" class="md-nav__link">
    逆序对
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" title="归并排序" class="md-nav__link">
    归并排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" title="线段树" class="md-nav__link">
    线段树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" title="树状数组" class="md-nav__link">
    树状数组
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" title="动态规划" class="md-nav__link">
    动态规划
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_32" title="背包问题" class="md-nav__link">
    背包问题
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" title="背包板子" class="md-nav__link">
    背包板子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poj1276" title="Poj1276[多重背包]" class="md-nav__link">
    Poj1276[多重背包]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poj218401" title="Poj2184[01背包变形]" class="md-nav__link">
    Poj2184[01背包变形]
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dp" title="状压DP" class="md-nav__link">
    状压DP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" title="线段树" class="md-nav__link">
    线段树
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" title="扫描线" class="md-nav__link">
    扫描线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" title="线段树+扫描线" class="md-nav__link">
    线段树+扫描线
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" title="树状数组" class="md-nav__link">
    树状数组
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" title="高精度" class="md-nav__link">
    高精度
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" title="高精度进制转换" class="md-nav__link">
    高精度进制转换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" title="大整数" class="md-nav__link">
    大整数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" title="评论" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../历年机试/" title="历年机试" class="md-nav__link">
      历年机试
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      ML & DL
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        ML & DL
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Concepts/" title="Concepts" class="md-nav__link">
      Concepts
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CNN/" title="CNN" class="md-nav__link">
      CNN
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../经典网络/" title="经典网络" class="md-nav__link">
      经典网络
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Normalization/" title="Normalization" class="md-nav__link">
      Normalization
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      NLP
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        NLP
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-1" type="checkbox" id="nav-5-1">
    
    <label class="md-nav__link" for="nav-5-1">
      NLP简介
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-1">
        NLP简介
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../自然语言处理简介/" title="自然语言处理简介" class="md-nav__link">
      自然语言处理简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../NLP的巨人肩膀/" title="NLP的巨人肩膀" class="md-nav__link">
      NLP的巨人肩膀
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Attention/" title="Attention" class="md-nav__link">
      Attention
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Neural Reading Comprehension and beyond/" title="Machine Reading Comprehension" class="md-nav__link">
      Machine Reading Comprehension
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-4" type="checkbox" id="nav-5-4">
    
    <label class="md-nav__link" for="nav-5-4">
      NMT
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-4">
        NMT
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../NMT Concepts/" title="NMT Concepts" class="md-nav__link">
      NMT Concepts
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-5" type="checkbox" id="nav-5-5">
    
    <label class="md-nav__link" for="nav-5-5">
      QA
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-5">
        QA
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../QA Concepts/" title="QA Concepts" class="md-nav__link">
      QA Concepts
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      Interview experience
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        Interview experience
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../面经/" title="我的面经" class="md-nav__link">
      我的面经
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6-2" type="checkbox" id="nav-6-2">
    
    <label class="md-nav__link" for="nav-6-2">
      实训笔记
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-6-2">
        实训笔记
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Protocol Buffers/" title="Protobuf" class="md-nav__link">
      Protobuf
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../FDBus/" title="FDBus" class="md-nav__link">
      FDBus
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../FDBus API/" title="FDBus API" class="md-nav__link">
      FDBus API
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../FDBus内部结构/" title="FDBus内部结构" class="md-nav__link">
      FDBus内部结构
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cross compiler/" title="Cross compiler" class="md-nav__link">
      Cross compiler
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      For MkDocs
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        For MkDocs
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../MkDocs_demo/" title="Demo" class="md-nav__link">
      Demo
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Material Theme Tutorial/" title="Material Theme Tutorial" class="md-nav__link">
      Material Theme Tutorial
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" title="基础算法" class="md-nav__link">
    基础算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" title="递归" class="md-nav__link">
    递归
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" title="汉诺塔" class="md-nav__link">
    汉诺塔
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="排序" class="md-nav__link">
    排序
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" title="快排" class="md-nav__link">
    快排
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="堆排" class="md-nav__link">
    堆排
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="拓扑排序" class="md-nav__link">
    拓扑排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" title="查找" class="md-nav__link">
    查找
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" title="二分查找" class="md-nav__link">
    二分查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" title="并查集" class="md-nav__link">
    并查集
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" title="位运算" class="md-nav__link">
    位运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" title="分数表示" class="md-nav__link">
    分数表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" title="字符串" class="md-nav__link">
    字符串
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" title="回文串" class="md-nav__link">
    回文串
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" title="树算法" class="md-nav__link">
    树算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" title="哈夫曼树" class="md-nav__link">
    哈夫曼树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" title="图算法" class="md-nav__link">
    图算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" title="最短路径" class="md-nav__link">
    最短路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" title="最小生成树" class="md-nav__link">
    最小生成树
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim" title="PRIM 算法¶" class="md-nav__link">
    PRIM 算法¶
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" title="KRUSKAL 算法" class="md-nav__link">
    KRUSKAL 算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" title="其他" class="md-nav__link">
    其他
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" title="斐波那契与卡塔兰数" class="md-nav__link">
    斐波那契与卡塔兰数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" title="欧几里得定理" class="md-nav__link">
    欧几里得定理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" title="矩阵连乘" class="md-nav__link">
    矩阵连乘
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" title="快速乘法" class="md-nav__link">
    快速乘法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" title="素数" class="md-nav__link">
    素数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" title="逆序对" class="md-nav__link">
    逆序对
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" title="归并排序" class="md-nav__link">
    归并排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" title="线段树" class="md-nav__link">
    线段树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" title="树状数组" class="md-nav__link">
    树状数组
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" title="动态规划" class="md-nav__link">
    动态规划
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_32" title="背包问题" class="md-nav__link">
    背包问题
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" title="背包板子" class="md-nav__link">
    背包板子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poj1276" title="Poj1276[多重背包]" class="md-nav__link">
    Poj1276[多重背包]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poj218401" title="Poj2184[01背包变形]" class="md-nav__link">
    Poj2184[01背包变形]
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dp" title="状压DP" class="md-nav__link">
    状压DP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" title="线段树" class="md-nav__link">
    线段树
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" title="扫描线" class="md-nav__link">
    扫描线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" title="线段树+扫描线" class="md-nav__link">
    线段树+扫描线
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" title="树状数组" class="md-nav__link">
    树状数组
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" title="高精度" class="md-nav__link">
    高精度
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" title="高精度进制转换" class="md-nav__link">
    高精度进制转换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" title="大整数" class="md-nav__link">
    大整数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" title="评论" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/looperxx/My_wiki/edit/master/docs/Coding Knowledge.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="_1">重点内容<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="_2">基础算法<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="_3">递归<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<h4 id="_4">汉诺塔<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp"># include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/**</span>

<span class="cm">-   打印 Hanoi塔移动过程</span>
<span class="cm">-   @param n 塔的层数</span>
<span class="cm">-   @param from 塔的开始位置</span>
<span class="cm">-   @param to 塔的结束位置</span>
<span class="cm">-   @param help 中介</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">printHanoiTower</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">help</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 递归终止</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;move &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; from &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">from</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; to &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">to</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">printHanoiTower</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">help</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span> <span class="c1">// 移动上面的 n - 1 层</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;move &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; from &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">from</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; to &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">to</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 移动最下面一层</span>
    <span class="n">printHanoiTower</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span> <span class="c1">// 将上面的 n - 1 层移回</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">from</span> <span class="o">=</span> <span class="s">&quot;A&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">to</span> <span class="o">=</span> <span class="s">&quot;B&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">help</span> <span class="o">=</span> <span class="s">&quot;C&quot;</span><span class="p">;</span>
    <span class="n">printHanoiTower</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">help</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_5">排序<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<h4 id="_6">快排<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 快速排序各类实现</span>

<span class="c1">// 快速排序.三指针分区法.cpp</span>

<span class="c1">// 快速排序 三指针分区法</span>
<span class="c1">// 类比单向扫描法，增加的是对小于、等于两种情况的区分</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * 快速排序</span>
<span class="cm"> * @param nums 被排序数组</span>
<span class="cm"> * @param low 首个元素索引</span>
<span class="cm"> * @param high 末尾元素索引</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不要忽略该判断，归并排序中也有类似判断</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">low</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="c1">// less than 指向首个不小于 pivot 的元素</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// pointer</span>
        <span class="kt">int</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span> <span class="c1">// greater than 指向最后一个不大于 pivot 的元素</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">gt</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">lt</span><span class="o">++</span><span class="p">]);</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">)</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">gt</span><span class="o">--</span><span class="p">]);</span>
            <span class="k">else</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// lt 到 gt 之间的数都等于 pivot，不必再排序</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">lt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">gt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 后两个参数是：首个元素的索引和末尾元素的索引</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 快速排序.单向扫描分区法.cpp</span>

<span class="c1">// 快速排序 一遍单向扫描法</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * 将数组按 pivot 切分</span>
<span class="cm"> * @param nums 被切分数组，nums[high]为pivot</span>
<span class="cm"> * @param low 首个元素索引</span>
<span class="cm"> * @param high 末尾元素索引</span>
<span class="cm"> * @return pivot 索引</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">high</span><span class="p">];</span> <span class="c1">// 以最后一个元素为 pivot</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// i 及其前面的元素小于等于 pivot</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意在循环过程中，pivot 不应被交换</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">high</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span> <span class="c1">// 交换 pivot 到合适位置</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 快速排序</span>
<span class="cm"> * @param nums 被排序数组</span>
<span class="cm"> * @param low 首个元素索引</span>
<span class="cm"> * @param high 末尾元素索引</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不要忽略该判断，归并排序中也有类似判断</span>
        <span class="kt">int</span> <span class="n">par</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">par</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">par</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 后两个参数是：首个元素的索引和末尾元素的索引</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 快速排序.双向扫描分区法.cpp</span>

<span class="c1">// 快速排序</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * 将数组按 pivot 切分</span>
<span class="cm"> * @param nums 被切分数组，nums[high]为pivot</span>
<span class="cm"> * @param low 首个元素索引</span>
<span class="cm"> * @param high 末尾元素索引</span>
<span class="cm"> * @return pivot 索引</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">low</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 必须取等</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span> <span class="n">left</span><span class="o">++</span><span class="p">;</span> <span class="c1">// left 指向首个大于 pivot 的元素</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="n">right</span><span class="o">--</span><span class="p">;</span> <span class="c1">// right 指向最后一个小于等于 pivot 的元素</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="c1">// 否则元素与自身交换没有意义</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">low</span><span class="p">]);</span> <span class="c1">// right 指向最后一个 小于等于 pivot 的元素</span>
    <span class="k">return</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 快速排序</span>
<span class="cm"> * @param nums 被排序数组</span>
<span class="cm"> * @param low 首个元素索引</span>
<span class="cm"> * @param high 末尾元素索引</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不要忽略该判断，归并排序中也有类似判断</span>
        <span class="kt">int</span> <span class="n">par</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">par</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">par</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">quickSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 后两个参数是：首个元素的索引和末尾元素的索引</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="_7">堆排<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">// heap 为堆，heap[1] 为根结点，n 为元素个数</span>
<span class="kt">int</span> <span class="n">heap</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>


<span class="c1">// 对 heap 数组在 [low, high] 范围进行向下调整</span>
<span class="c1">// 其中 low 为欲调整结点的数组下标，high 一般为堆的最后一个元素的数组下标</span>
<span class="c1">// 时间复杂度O(log n)</span>
<span class="kt">void</span> <span class="nf">downAdjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// i 为欲调整结点，j  为其左孩子</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 存在孩子结点</span>
        <span class="c1">// 如果右孩子存在，且右孩子的值大于左孩子</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 让 j 存储右孩子下标</span>

        <span class="c1">// 如果孩子中的最大权值比欲调整结点i大</span>
        <span class="k">if</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 交换最大权值的孩子与欲调整结点i</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// 保持 i 为欲调整结点，j 为 i 的左孩子</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 孩子的权值均比欲调整结点i小，调整结束</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 建堆：时间复杂度O(n)，证明可参考《算法导论》</span>
<span class="kt">void</span> <span class="nf">createHeap</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">downAdjust</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 删除堆顶元素：每次删除堆中元素只能删除当前堆顶</span>
<span class="c1">// 时间复杂度O(log n)</span>
<span class="kt">void</span> <span class="nf">deleteTop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">heap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">n</span><span class="o">--</span><span class="p">];</span> <span class="c1">// 用最后一个元素覆盖堆顶元素，并让元素个数减1</span>
    <span class="n">downAdjust</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 向下调整堆顶元素</span>
<span class="p">}</span>

<span class="c1">// 向上调整：用于添加元素到堆时，元素添加到最后一个结点后进行调整</span>
<span class="c1">// 时间复杂度O(log n)</span>
<span class="c1">// 对 heap 数组在 [low, high] 范围进行向上调整</span>
<span class="c1">// 其中 low 一般设置为1，high 表示欲调整结点的数组下标</span>
<span class="kt">void</span> <span class="nf">upAdjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">high</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// i 为欲调整结点，j 为其父亲</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">low</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 父亲在 [low, high] 范围内</span>
        <span class="k">if</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 交换父亲和欲调整结点</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// 保持 i 为欲调整结点，j 为 i 的父亲</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// 父亲权值比欲调整结点i的权值大，调整结束</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 添加元素x</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">heap</span><span class="p">[</span><span class="o">++</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 让元素个数加1，然后将数组末位赋值为x</span>
    <span class="n">upAdjust</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 向上调整新加入的结点</span>
<span class="p">}</span>

<span class="c1">// 堆排序</span>
<span class="kt">void</span> <span class="nf">heapSort</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">createHeap</span><span class="p">();</span> <span class="c1">// 建堆</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 倒着枚举，直至堆中只有一个元素</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">heap</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 交换 heap[i] 与堆顶</span>
        <span class="n">downAdjust</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 调整堆顶</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="_8">拓扑排序<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// LeetCode_210 https://leetcode.com/problems/course-schedule-ii/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inDegree</span><span class="p">(</span><span class="n">numCourses</span><span class="p">);</span> <span class="c1">// 入度为 0 时顶点可以删除</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// 存储入度为 0 的顶点</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 放入 res 的元素个数</span>

        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">p</span> <span class="p">:</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="n">inDegree</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>

            <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">j</span> <span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur</span><span class="p">]){</span>
                <span class="n">inDegree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<h3 id="_9">查找<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<h4 id="_10">二分查找<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 二分搜索、lower_bound、upper_bound 的实现</span>

<span class="c1">// lower_bound.cpp</span>

<span class="c1">// a为递增序列，x为欲查询的数，函数返回第一个大于等于x的元素的位置</span>
<span class="c1">// n是a的元素个数，查询区间是[left, right] = [0, n]</span>
<span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// mid为left和right的中点</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left==right 意味着找到唯一位置</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// upper_bound.cpp</span>

<span class="c1">// a为递增序列，x为欲查询的数，函数返回第一个大于x的元素的位置</span>
<span class="c1">// n是a的元素个数，查询区间是[left, right] = [0, n]</span>
<span class="kt">int</span> <span class="nf">upper_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// mid为left和right的中点</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left==right 意味着找到唯一位置</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 二分搜索.cpp</span>

<span class="c1">// a为递增序列</span>
<span class="c1">// n是a的元素个数，查询区间是[left, right]，传入初值是[0, n - 1]</span>
<span class="kt">int</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// mid为left和right的中点</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果大于，无法形成闭区间</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 相对地避免溢出</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// 找到x，返回下标</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 往左子区间查找</span>
        <span class="k">else</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 往右子区间查找</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 查找失败</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="_11">并查集<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 并查集模板：初始化、查找、合并、路径压缩</span>


<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 令father[i]为-1也可</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 递推查找</span>
<span class="kt">int</span> <span class="nf">findFather</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 递归查找</span>
<span class="kt">int</span> <span class="nf">findFather</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 如果找到根结点，则返回根结点编号x</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">findFather</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// 否则，递归判断x的父亲结点是否是根结点</span>
<span class="p">}</span>

<span class="c1">// 合并</span>
<span class="kt">void</span> <span class="nf">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">findFather</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">findFather</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fa</span> <span class="o">!=</span> <span class="n">fb</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">father</span><span class="p">[</span><span class="n">fa</span><span class="p">]</span> <span class="o">=</span> <span class="n">fb</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 路径压缩 迭代实现</span>
<span class="kt">int</span> <span class="nf">findFather</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 由于x在下面的while中会变成根结点，因此先把原x保存</span>
    <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>

    <span class="c1">// x此时为根结点，下面将路径上的所有结点的father都改成根结点</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">father</span><span class="p">[</span><span class="n">cur</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span> <span class="c1">// 因为cur要被father[cur]覆盖，所以先保存</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">father</span><span class="p">[</span><span class="n">cur</span><span class="p">];</span> <span class="c1">// 回溯父结点</span>
        <span class="n">father</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 将原先的结点的父亲改为根结点</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 返回根结点</span>
<span class="p">}</span>

<span class="c1">// 路径压缩 递归实现</span>
<span class="kt">int</span> <span class="nf">findFather</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">father</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">return</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 找到根结点</span>
    <span class="n">father</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">findFather</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">father</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_12">位运算<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>判断一个数字x二进制下第i位是不是等于1</p>
<ul>
<li><code>if(((1&lt;&lt;(i−1))&amp;x)&gt;0)</code></li>
</ul>
<blockquote>
<p>将1左移i-1位，相当于制造了一个只有第i位上是1，其他位上都是0的二进制数。然后与x做与运算，如果结果&gt;0，说明x第i位上是1，反之则是0。</p>
</blockquote>
</li>
<li>
<p>将一个数字x二进制下第i位更改成1。</p>
<ul>
<li><code>x=x|(1&lt;&lt;(i−1))</code></li>
</ul>
</li>
<li>
<p>把一个数字二进制下最靠右的第一个1去掉</p>
<ul>
<li><code>x=x&amp;(x−1)</code></li>
</ul>
</li>
<li>
<p>判断n是不是2的次幂</p>
<ul>
<li>(n &gt; 0 &amp;&amp; ((n &amp; (n - 1)) == 0)</li>
</ul>
<blockquote>
<p>因为2的次幂 二进制下只有一个1 所以 减一以后 最高位变为0 后面的都变为1， &amp;之后 就变为0了 所以本题中 i的1的个数 等于他去掉最低位的1之后的i&amp;(i-1)的1的个数再+1</p>
</blockquote>
</li>
</ul>
<h3 id="_13">分数表示<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 分数的表示</span>
<span class="c1">// 常用假分数的形式表示</span>
<span class="c1">// 设分母为非负数；如果分数为负，令分子为负即可</span>
<span class="c1">// 分子和分母没有除了1以外的公约数，即总是约分</span>
<span class="k">struct</span> <span class="n">Fraction</span> <span class="p">{</span> <span class="c1">// 分数</span>
    <span class="kt">int</span> <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">;</span> <span class="c1">// 分子，分母</span>
<span class="p">}</span>

<span class="c1">// 分数化简</span>
<span class="c1">// 如果分母为负数，分子、分母都取相反数</span>
<span class="c1">// 如果分子为0，令分母为1</span>
<span class="c1">// 约分：求出分子绝对值与分母绝对值的最大公约数d，令分子分母同时除以d</span>
        <span class="n">Fraction</span> <span class="n">reduction</span><span class="p">(</span><span class="n">Fraction</span> <span class="n">result</span><span class="p">){</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">down</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
<span class="n">result</span><span class="p">.</span><span class="n">down</span> <span class="o">=</span> <span class="o">-</span><span class="n">result</span><span class="p">.</span><span class="n">down</span><span class="p">;</span>
<span class="n">result</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="o">-</span><span class="n">result</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">up</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">result</span><span class="p">.</span><span class="n">down</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">else</span><span class="p">{</span>
<span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">GCD</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">up</span><span class="p">),</span> <span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">down</span><span class="p">));</span>
<span class="n">result</span><span class="p">.</span><span class="n">up</span> <span class="o">/=</span> <span class="n">d</span><span class="p">;</span>
<span class="n">result</span><span class="p">.</span><span class="n">down</span> <span class="o">/=</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 分数的加法</span>

<span class="n">Fraction</span> <span class="n">add</span><span class="p">(</span><span class="n">Fraction</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Fraction</span> <span class="n">f2</span><span class="p">){</span>
    <span class="n">Fraction</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">up</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">down</span> <span class="o">+</span> <span class="n">f2</span><span class="p">.</span><span class="n">up</span> <span class="o">*</span> <span class="n">f1</span><span class="p">.</span><span class="n">down</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">down</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">down</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">down</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">reduction</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 分数的减法</span>

<span class="n">Fraction</span> <span class="n">minu</span><span class="p">(</span><span class="n">Fraction</span> <span class="n">f</span><span class="p">){</span>
    <span class="n">f</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">reduction</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Fraction</span> <span class="n">minu</span><span class="p">(</span><span class="n">Fraction</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Fraction</span> <span class="n">f2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">minu</span><span class="p">(</span><span class="n">f2</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// 分数的乘法</span>

<span class="n">Fraction</span> <span class="n">multi</span><span class="p">(</span><span class="n">Fraction</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Fraction</span> <span class="n">f2</span><span class="p">){</span>
    <span class="n">Fraction</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">up</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">down</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">down</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">down</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">reduction</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 分数的除法</span>

<span class="n">Fraction</span> <span class="n">divide</span><span class="p">(</span><span class="n">Fraction</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Fraction</span> <span class="n">f2</span><span class="p">){</span>
    <span class="n">Fraction</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">up</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">down</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">down</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">down</span> <span class="o">*</span> <span class="n">f2</span><span class="p">.</span><span class="n">up</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">reduction</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 输出分数前，进行化简。</span>
<span class="c1">// 如果分母为1，则该分数为整数，直接输出分子。</span>
<span class="c1">// 如果分子绝对值大于分母，则该分数为假分数，应以带分数的形式输出。</span>
<span class="c1">// 若以上均不满足，则分数是真分数，按原样输出即可。</span>
<span class="kt">void</span> <span class="n">showResult</span><span class="p">(</span><span class="n">Fraction</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">reduction</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">down</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lld&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">up</span><span class="p">);</span> <span class="c1">// 整数</span>
    <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">up</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">.</span><span class="n">down</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 假分数</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d/%d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">up</span> <span class="o">/</span> <span class="n">r</span><span class="p">.</span><span class="n">down</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">up</span><span class="p">)</span> <span class="o">%</span> <span class="n">r</span><span class="p">.</span><span class="n">down</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">down</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d/%d&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">up</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">down</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_14">字符串<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<h4 id="_15">回文串<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 回文串判断.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">judge</span><span class="p">(</span><span class="kt">char</span> <span class="n">str</span><span class="p">[]){</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="c1">// 字符串长度</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 枚举字符串前一半</span>
        <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">str</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 输入字符串</span>
        <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">judge</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="c1">// 判断字符串str是否是回文串</span>
        <span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;YES&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;NO&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_16">树算法<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<h4 id="_17">哈夫曼树<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<p>路径长度：两点路径上的分枝数目称作路径长度。</p>
<p>树的路径长度：从树根到每个结点的路径长度之和。</p>
<p>结点的带权路径长度：在一棵树中，假设其结点上附带有一个权值，通常把该结点的路径长度与该结点上的权值</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cm">/*</span>
<span class="cm">题目大意：FJ需要修补牧场的围栏，他需要 N 块长度为 Li 的木头（N planks of woods）。开始时，FJ只有一块无限长的木板，因此他需要把无限长的木板锯成 N 块长度 为 Li 的木板，Farmer Don提供FJ锯子，但必须要收费的，收费的标准是对应每次据出木块的长度，比如说测试数据中 5 8 8</span>

<span class="cm">他希望将长度为21的木板切成长度为8,5和8的木板</span>
<span class="cm">8 + 5 + 8 = 21。第一次切割将花费21美元，并且应该用于将板切割成13和8片。第二次切割将花费13，并且应该用于将13切割成8和5.这将花费21 + 13 = 34 。如果21被切割成16和5，则第二次切割将花费16次，总共37（大于34）。</span>

<span class="cm">题目可以转化为Huffman树构造问题 / 优先队列：</span>
<span class="cm">通过每次选取两块长度最短的木板，合并，最终必定可以合并出长度为 Sum（Li）的木板，并且可以保证总的耗费最少</span>
<span class="cm"> * */</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span> <span class="c1">// 小顶堆</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">temp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 输入到优先级队列</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 只要堆中至少有两个元素，就继续执行合并</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// 取出栈顶</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>        
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_18">图算法<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<h4 id="_19">最短路径<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Dijkstra.邻接矩阵.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define MAXV 1010</span>
<span class="cp">#define INF 0x3f3f3f3f</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// 顶点个数，边数，起点编号</span>
<span class="kt">int</span> <span class="n">G</span><span class="p">[</span><span class="n">MAXV</span><span class="p">][</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// MAXV为最大顶点数</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// 起点到达各点的最短路径长度</span>
<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">MAXV</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span> <span class="c1">// 表示是否访问的数组</span>

<span class="kt">void</span> <span class="nf">Dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s为起点</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="n">MAXV</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span> <span class="c1">// 相当于C语言的memset</span>
    <span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 起点到达自身的距离为0，不要把起点标记为已访问</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 循环次数为顶点的数量</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">MIN</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> <span class="c1">// 找到u使得d[u]最小，MIN存放该最小的d[u]</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">MIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">MIN</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 找不到小于INF的d[i]，说明剩下的顶点和起点s不连通</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记u为已访问</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果v未访问 且 u能到达v 且 以u为中介点可以使d[v]更优</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// 顶点个数，边数，起点编号</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">MAXV</span> <span class="o">*</span> <span class="n">MAXV</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span> <span class="c1">// 初始化图G</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">w</span><span class="p">;</span>
        <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Dijkstra</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Dijkstra 算法入口</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span> <span class="c1">// 输出起点到所有顶点的最短距离</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Floyd.cpp</span>
<span class="kt">int</span> <span class="n">dis</span><span class="p">[</span><span class="n">MAXV</span><span class="p">][</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// dis[i][j] 表示顶点i到顶点j的距离</span>

<span class="kt">void</span> <span class="nf">Floyd</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Bellman-Ford.cpp</span>

<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">dis</span><span class="p">;</span> <span class="c1">// v为邻接边的目标顶点，dis 为邻接边的边权</span>
<span class="p">}</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span>
<span class="n">Adj</span><span class="p">[</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// 图G的邻接表</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// n为顶点数，MAXV 为最大顶点数</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// 起点到达各点的最短路径长度</span>

<span class="kt">bool</span> <span class="nf">Bellman</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s为源点</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="n">MAXV</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span> <span class="c1">// fill函数将整个d数组赋为INF，注意慎用INF</span>
    <span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 起点s到达自身的距离为0</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 执行 n-1 轮操作，n 为顶点数</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 每轮操作都遍历所有边</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">;</span> <span class="c1">// 邻接边的顶点</span>
                <span class="kt">int</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">dis</span><span class="p">;</span> <span class="c1">// 邻接边的边权</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 以下为判断负环的代码</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 对每条边进行判断</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">;</span> <span class="c1">// 邻接边的顶点</span>
            <span class="kt">int</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">dis</span><span class="p">;</span> <span class="c1">// 邻接边的边权</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="c1">// 如果仍可以被松弛</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 说明图中有从源点可达的负环</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 数组d的所有值都已经达到最优</span>
<span class="p">}</span>

<span class="c1">// SPFA.cpp</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">Adj</span><span class="p">[</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// 图G的邻接表</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">MAXV</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// num数组记录顶点的入队次数</span>
<span class="kt">bool</span> <span class="n">inq</span><span class="p">[</span><span class="n">MAXV</span><span class="p">];</span> <span class="c1">// 顶点是否在队列中</span>

<span class="kt">bool</span> <span class="nf">SPFA</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s为源点</span>
    <span class="c1">// 初始化</span>
    <span class="n">metset</span><span class="p">(</span><span class="n">inq</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inq</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">num</span><span class="p">));</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="n">MAXV</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>

    <span class="c1">// 源点入队部分</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// 源点入队</span>
    <span class="n">inq</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 源点已入队</span>
    <span class="n">num</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 源点入队次数加1</span>
    <span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 源点的距离为 0</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="c1">// 队首顶点编号为 u</span>
        <span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// 出队</span>
        <span class="n">inq</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 设置 u 为不在队列中</span>
        <span class="c1">// 遍历 u 的所有邻接边 v</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">dis</span><span class="p">;</span>
            <span class="c1">// 松弛操作</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inq</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 如果 v 不在队列中</span>
                    <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// v 入队</span>
                    <span class="n">inq</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 设置 v 为在队列中</span>
                    <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 有可达负环</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 无可达负环</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="_20">最小生成树<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<p>Prim 算法和 Kruskal 算法两者都是贪心算法，但两者都能获得最小生成树的精确最优解。前者是寻找顶点的过程，更适合稠密图；后者是寻找边的过程，更适合稀疏图。</p>
<h5 id="prim">PRIM 算法<a href="https://looperxx.github.io/My_wiki/Algorithm Details/#prim">¶</a><a class="headerlink" href="#prim" title="Permanent link">&para;</a></h5>
<p>Prim 算法的关键两步是寻找顶点与更新最短距离。 该算法设定集合S，尝试不断向S中添加顶点来生成最小生成树。当找到S之外距离S集合最近的顶点u后，更新u的所有邻接顶点到集合S的最短距离，并不断循环添加顶点。直到找不到这样的顶点u，即剩余顶点不与S连通，或所有顶点都已被加入到最小生成树。</p>
<p>邻接矩阵的实现：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="n">maxv</span><span class="p">][</span><span class="n">maxv</span><span class="p">];</span> <span class="c1">// n为顶点数量，maxv 为最大顶点数</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span> <span class="c1">// 顶点与集合S的最短距离</span>
<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span> <span class="c1">// 标记数组</span>

<span class="kt">int</span> <span class="nf">prim</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 默认 0 号为初始点，函数返回最小生成树的边权之和</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="n">maxv</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 存放最小生成树的边权之和</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">MIN</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> 
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 找到未访问的顶点中距离当前生成的集合最近的顶点</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">MIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">MIN</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span> 
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 找不到顶点，即剩下的顶点与集合S不连通</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="c1">// 最小生成树的边权累加</span>
        <span class="c1">// 更新剩余顶点到集合S的距离</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>邻接表的实现：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">dis</span><span class="p">;</span> <span class="c1">// 目标顶点和边权</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">nei</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span> <span class="c1">// 邻接表，nei[u]存放顶点u出发的边</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 顶点数</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span> <span class="c1">// 顶点到集合S的最短距离</span>
<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span> <span class="c1">// 标记数组</span>

<span class="kt">int</span> <span class="nf">prim</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 默认0号为初始点，函数返回最小生成树的边权之和</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="n">maxv</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">MIN</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">MIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">MIN</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">vis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
    <span class="c1">// 只有下面这个循环与邻接矩阵的实现不同</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nei</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">nei</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">nei</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">dis</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h5 id="kruskal">KRUSKAL 算法<a class="headerlink" href="#kruskal" title="Permanent link">&para;</a></h5>
<p>Kruskal 算法使用并查集。先将图中所有边按照边权从小到大进行排序，然后开始遍历每条边，通过并查集将判断并将边添加到最小生成树的集合。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">Edge</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 边的两个端点编号</span>
    <span class="kt">int</span> <span class="n">cost</span><span class="p">;</span> <span class="c1">// 边权</span>
<span class="p">}</span> <span class="n">edges</span><span class="p">[</span><span class="n">maxe</span><span class="p">];</span> <span class="c1">// 最多有 maxe 条边</span>

<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">Edge</span> <span class="n">a</span><span class="p">,</span> <span class="n">Edge</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 并查集部分</span>
<span class="kt">int</span> <span class="n">F</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span> <span class="c1">// 并查集数组</span>
<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 并查集查询函数</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">F</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 路径压缩</span>
    <span class="k">while</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">F</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
        <span class="n">F</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Kruskal 算法</span>
<span class="cm"> * @param n 顶点个数</span>
<span class="cm"> * @param m 图的边数</span>
<span class="cm"> * @return 所求边权只和；若无法连通返回-1</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">Kruskal</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ans 为所求边权之和，numEdge 为当前生成树的边数</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numEdge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 顶点范围是[0...n-1]</span>
        <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 并查集初始化</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edges</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 所有边按照边权排序</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 枚举所有边</span>
        <span class="kt">int</span> <span class="n">faU</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">);</span> <span class="c1">// 查询测试边两个端点所在集合的根结点</span>
        <span class="kt">int</span> <span class="n">faV</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">faU</span> <span class="o">!=</span> <span class="n">faV</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果不在一个集合中，该边尚未加入到最小生成树中</span>
            <span class="n">F</span><span class="p">[</span><span class="n">faU</span><span class="p">]</span> <span class="o">=</span> <span class="n">faV</span><span class="p">;</span> <span class="c1">// 合并集合，将测试边加入到最小生成树中</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span> 
            <span class="n">numEdge</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 当前生成树的边数加1</span>
            <span class="k">if</span><span class="p">(</span><span class="n">numEdge</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 所有边都已添加</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">numEdge</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 无法连通时返回 -1</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span> <span class="c1">// 返回最小生成树的边权之和</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// 顶点数量，边数量</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span> <span class="c1">// 两个端点编号，边权</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">Kruskal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_21">其他<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<h4 id="_22">斐波那契与卡塔兰数<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h4>
<h4 id="_23">欧几里得定理<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<blockquote>
<p><a href="https://www.cnblogs.com/fisherss/p/9985135.html">https://www.cnblogs.com/fisherss/p/9985135.html</a></p>
</blockquote>
<h4 id="_24">矩阵连乘<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#define maxn 100</span>
<span class="cp">#define inf 0x3f3f3f3f</span>

<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span> <span class="c1">// 初始对角线为0</span>
<span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span> <span class="c1">// 切割矩阵链，存储前半段矩阵链的最后一个矩阵的索引</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// 连乘的矩阵数量</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">inf</span><span class="p">;</span> <span class="c1">// 上对角线初始化为 inf</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 每次循环的矩阵链的长度</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// i 是矩阵链开始</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 当前矩阵链是矩阵i到矩阵j</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// k 是矩阵链切割位置</span>
                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="_25">快速乘法<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">LL</span><span class="p">;</span>

<span class="n">LL</span> <span class="nf">mul</span><span class="p">(</span><span class="n">LL</span> <span class="n">a</span><span class="p">,</span> <span class="n">LL</span> <span class="n">b</span><span class="p">,</span> <span class="n">LL</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LL</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 标量快速幂 迭代</span>

<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">LL</span><span class="p">;</span>

<span class="n">LL</span> <span class="nf">binaryPow</span><span class="p">(</span><span class="n">LL</span> <span class="n">a</span><span class="p">,</span> <span class="n">LL</span> <span class="n">b</span><span class="p">,</span> <span class="n">LL</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LL</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">a</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 标量快速幂.递归</span>

<span class="c1">// 求 a^b % m，递归写法</span>

<span class="n">LL</span> <span class="nf">binaryPow</span><span class="p">(</span><span class="n">LL</span> <span class="n">a</span><span class="p">,</span> <span class="n">LL</span> <span class="n">b</span><span class="p">,</span> <span class="n">LL</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 如果b为0，则a为1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">binaryPow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">LL</span> <span class="n">mul</span> <span class="o">=</span> <span class="n">binaryPow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">mul</span> <span class="o">*</span> <span class="n">mul</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 矩阵快速幂.cpp</span>

<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">LL</span><span class="p">;</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="n">LL</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span> <span class="c1">// 长整数向量</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="n">vec</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span> <span class="c1">// 长整数矩阵</span>

<span class="n">mat</span> <span class="nf">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">mat</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat</span> <span class="o">&amp;</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 矩阵乘法 A multiply B</span>
    <span class="n">mat</span> <span class="n">C</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vec</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()));</span> <span class="c1">// 大小为 A 的行数与 B 的列数</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Ci</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ci</span> <span class="o">+</span> <span class="p">(</span><span class="n">Ai</span> <span class="o">*</span> <span class="n">Bk</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>
                <span class="c1">// 如果必要，此处的乘法以快速乘法代替</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">C</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">mat</span> <span class="nf">pow</span><span class="p">(</span><span class="n">mat</span> <span class="n">A</span><span class="p">,</span> <span class="n">LL</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 计算矩阵 A^n</span>
    <span class="c1">// 矩阵乘法的零元是单位矩阵</span>
    <span class="n">mat</span> <span class="n">An</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vec</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">Ani</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">An</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">An</span><span class="p">);</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">An</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="_26">素数<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 素数筛判断 x到y的素数个数 （包括x和y）</span>

<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXY</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">comp</span><span class="p">[</span><span class="n">MAXY</span><span class="p">];</span> <span class="c1">// 合数为 true</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
    <span class="c1">// 注意，此题没有说明 x 和 y 的大小关系</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 埃式筛法</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 质数</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">comp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 统计素数个数</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">comp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">// 注意 1 不是质数</span>
            <span class="n">ans</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 求解质因数个数 不重复</span>

<span class="kt">int</span> <span class="nf">getPrimeNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="n">res</span><span class="o">++</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">val</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">/=</span> <span class="n">i</span><span class="p">;</span>

        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">old</span><span class="p">)</span> <span class="n">res</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 不包括自身时 需要加上 val != old</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="_27">逆序对<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h4>
<p>逆序对：设 A 为一个有 n 个数字的有序集 (n&gt;1)，其中所有数字各不相同。如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则 A[i], A[j]&gt; 这个有序对称为 A 的一个逆序对，也称作逆序数。</p>
<h5 id="_28">归并排序<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h5>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>归并排序：（即使序列存在相同元素，该算法也适用，且代码不用修改） 
归并排序是将数列a[l,h]分成两半a[l,mid]和a[mid+1,h]分别进行归并排序，然后再将这两半合并起来。
在合并的过程中（设l&lt;=i&lt;=mid ,mid+1&lt;=j&lt;=h), 当a[i]&lt;=a[j]时，并不产生逆序数；
当a[i]&gt;a[j]时，在前半部分中比a[i]大的数都比a[j]大，将a[j]放在a[i]前面的话，逆序数要加上mid+1-i。
因此，可以在归并排序中的合并过程中计算逆序数.
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"></span>
<span class="cp">#define LL long long</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">50000</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXM</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span><span class="n">temp</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="n">LL</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">le</span><span class="p">,</span><span class="kt">int</span> <span class="n">mid</span><span class="p">,</span><span class="kt">int</span> <span class="n">ri</span><span class="p">){</span><span class="c1">//使每两部分【都已经分别有序】，合并为一个有序集合 </span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
    <span class="c1">// le到mid 是一个有序部分，mid+1到ri是一个有序部分 ，合并就行了  </span>
    <span class="n">i</span><span class="o">=</span><span class="n">le</span><span class="p">;</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">=</span><span class="n">le</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">ri</span><span class="p">;){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
            <span class="n">ans</span><span class="o">+=</span><span class="n">mid</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span>  <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">ri</span><span class="p">)</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">le</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">ri</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">le</span><span class="p">,</span><span class="kt">int</span> <span class="n">ri</span><span class="p">){</span><span class="c1">//不断的分为一半，来使各个部分非递减有序 </span>
    <span class="k">if</span><span class="p">(</span><span class="n">le</span><span class="o">&lt;</span><span class="n">ri</span><span class="p">){</span>
        <span class="kt">int</span>  <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">le</span><span class="o">+</span><span class="n">ri</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">le</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ri</span><span class="p">);</span>
        <span class="n">merge</span><span class="p">(</span><span class="n">le</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">ri</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">while</span><span class="p">(</span><span class="o">~</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">merge_sort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h5 id="_29">线段树<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h5>
<h5 id="_30">树状数组<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h5>
<p><a href="https://blog.csdn.net/qq_37383726/article/details/76459527">https://blog.csdn.net/qq_37383726/article/details/76459527</a></p>
<h2 id="_31">动态规划<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h2>
<h3 id="_32">背包问题<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h3>
<h4 id="_33">背包板子<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#define maxn 1000;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">cash</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">ZeroOne_Pack</span><span class="p">(</span><span class="kt">int</span> <span class="n">cost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cash</span><span class="p">;</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">cost</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">cost</span><span class="p">]</span><span class="o">+</span><span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Complete_Pack</span><span class="p">(</span><span class="kt">int</span> <span class="n">cost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cost</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">cash</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">cost</span><span class="p">]</span><span class="o">+</span><span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">Multi_Pack</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">));</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cash</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//物品全装进去超重，说明物品无限，直接套完全背包</span>
      <span class="n">Complete_Pack</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">//利用二进制思想，把物品分成1，2，4，8个，依次01背包，能凑出任何数值，降复杂度</span>
        <span class="n">ZeroOne_Pack</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">k</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">k</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">ZeroOne_Pack</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">cash</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="poj1276">Poj1276[多重背包]<a class="headerlink" href="#poj1276" title="Permanent link">&para;</a></h4>
<blockquote>
<p><a href="https://blog.csdn.net/xiajiawei0206/article/details/19933781">关于01背包一维时的逆序问题</a></p>
</blockquote>
<ul>
<li>二进制转化<ul>
<li>转换成01背包，例如一件物品可以拿26件，每一件的权值是w，26可以写成（1+2+4+8）+11，所以就把这种物品分解成权重为w，2w，4w，8w，11w的五种物品，这五种物品组合，一定能组成小于等于26的任意一个数，这样就把有26件的一种物品换成了五种各有一件的物品，用01背包就能解决了</li>
<li>慢 内存占用小</li>
<li>多开空间</li>
</ul>
</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">cash</span><span class="p">,</span> <span class="n">N</span><span class="p">;</span> <span class="c1">// N是钞票种数</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">D</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span> <span class="c1">// n是钞票数，D是钞票面额；</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">100010</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">N</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cash 是金额上限，本题的重量和价值合一，金额上限可理解为背包重量上限</span>
        <span class="c1">// 输入与初始化</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">));</span>
        <span class="c1">// 多重背包</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 第i种钞票</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cash</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 钞票充足，套用完全背包</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">cash</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// j是重量</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// if n[i] * D[i] &lt;= cash</span>
                <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 剩余钞票数</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 钞票数；使用二进制优化，k为2的幂，依次0-1背包，可凑出任意数值</span>
                    <span class="kt">int</span> <span class="n">mul</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">cash</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">mul</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// j是重量</span>
                        <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">mul</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">mul</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="p">}</span>
                    <span class="n">num</span> <span class="o">-=</span> <span class="n">mul</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 输出</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">cash</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>维护一个数组num，<span><span class="MathJax_Preview">num[i][j]num[i][j]</span><script type="math/tex">num[i][j]num[i][j]</script></span> 表示在往背包里试着装第i件物品时，背包容量使用了j时装了多少件i物品。cost[i]为物品i的体积，<span><span class="MathJax_Preview">num[i][j]=num[j−cost[i]]+1num[i][j]=num[j−cost[i]]+1</span><script type="math/tex">num[i][j]=num[j−cost[i]]+1num[i][j]=num[j−cost[i]]+1</script></span> ;可以看到<span><span class="MathJax_Preview">num[i][j]num[i][j]</span><script type="math/tex">num[i][j]num[i][j]</script></span>和<span><span class="MathJax_Preview">num[t|t!=i][j|j=1,2,....v]num[t|t!=i][j|j=1,2,....v]</span><script type="math/tex">num[t|t!=i][j|j=1,2,....v]num[t|t!=i][j|j=1,2,....v]</script></span>没有任何关系，所以可以省掉第一维，对于每一种物品，清空num，只计算num[j]就行了</p>
<ul>
<li>快 内存占用大</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;climits&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;list&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp"></span>
<span class="cp">#define mem(a) memset(a,0,sizeof(a))</span>

<span class="k">using</span>  <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">wi</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">mi</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">100050</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">num</span><span class="p">[</span><span class="mi">100050</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ans_v</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ans_v</span><span class="p">)</span><span class="o">!=</span><span class="n">EOF</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">mem</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
        <span class="n">mem</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="o">&amp;</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">mem</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">ans_v</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">&lt;</span><span class="n">mi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">wi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">dp</span><span class="p">[</span><span class="n">ans_v</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="poj218401">Poj2184[01背包变形]<a class="headerlink" href="#poj218401" title="Permanent link">&para;</a></h4>
<ul>
<li>使得TS和TF的值的和最大，同时TS和TF都不能为0</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp"></span>

<span class="cp">#define MAXN 105</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">100005</span><span class="p">;</span> <span class="c1">// TS或TF最大为100000</span>
<span class="kt">int</span> <span class="n">S</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="p">];</span> <span class="c1">// dp[i]表示S值为i时F的最大值；坐标平移：负数在前，正数在后</span>
<span class="c1">// 将S看做代价，F看做价值，0-1背包求解</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">N</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">100000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 0前有十万个负数，0后有十万个正数</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">INT_MIN</span><span class="p">)</span> <span class="c1">// 背包重量为 j - S[i] 的情况存在</span>
                        <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// if S[i] &lt; 0，如果放入背包，背包变轻，逆序遍历</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">INT_MIN</span><span class="p">)</span>
                        <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//TF值大于0 显然这里的TS=i-100000&gt;0 </span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">100000</span><span class="p">);</span> <span class="c1">// dp[i] + i 即 TS + TF，然后恢复坐标平移</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="dp">状压DP<a class="headerlink" href="#dp" title="Permanent link">&para;</a></h3>
<blockquote>
<p><a href="https://www.cnblogs.com/Tony-Double-Sky/p/9283254.html">https://www.cnblogs.com/Tony-Double-Sky/p/9283254.html</a></p>
</blockquote>
<p>状压就是将问题可能遇到的每一个状态用一个唯一的二进制数表示</p>
<p>状压位运算</p>
<ul>
<li>判断一个数字x二进制下第i位是不是等于1。<ul>
<li>方法：if(((1&lt;&lt;(i−1))&amp;x)&gt;0)</li>
<li>将1左移i-1位，相当于制造了一个只有第i位上是1，其他位上都是0的二进制数。然后与x做与运算，如果结果&gt;0，说明x第i位上是1，反之则是0。</li>
</ul>
</li>
<li>将一个数字x二进制下第i位更改成1。<ul>
<li>方法：x=x|(1&lt;&lt;(i−1))</li>
<li>证明方法与1类似，此处不再重复证明。</li>
</ul>
</li>
<li>把一个数字二进制下最靠右的第一个1去掉。<ul>
<li>方法：x=x&amp;(x−1)</li>
</ul>
</li>
</ul>
<h3 id="_34">线段树<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// https://leetcode.com/problems/range-sum-query-mutable/ 线段树保存可变区间和</span>

<span class="c1">// 数组法</span>
<span class="k">class</span> <span class="nc">NumArray</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">NumArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">tree</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">+=</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
            <span class="n">i</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">+=</span> <span class="n">n</span><span class="p">,</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="o">--</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 构造SegmentTreeNode类</span>
<span class="cm">/*</span>
<span class="cm"> * 本题实现的函数：NumArray 类的构造函数，sumRange，update</span>
<span class="cm"> * 本代码使用线段树实现该类，NumArray 包含一个子类 SegmentTreeNode</span>
<span class="cm"> */</span>

<span class="k">class</span> <span class="nc">NumArray</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 成员变量与子类</span>
    <span class="k">class</span> <span class="nc">SegmentTreeNode</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>
        <span class="n">SegmentTreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>

        <span class="c1">// 线段树构造函数</span>
        <span class="n">SegmentTreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="o">:</span>
                <span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">e</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="c1">// 线段树析构函数</span>
        <span class="o">~</span><span class="n">SegmentTreeNode</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
                <span class="k">delete</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
                <span class="k">delete</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">SegmentTreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// 成员方法</span>

    <span class="cm">/*</span>
<span class="cm">     * 类的构造函数</span>
<span class="cm">     * @param nums 数组</span>
<span class="cm">     */</span>
    <span class="n">NumArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * 线段树的构造</span>
<span class="cm">     * @param nums 数组</span>
<span class="cm">     * @param s 起始索引</span>
<span class="cm">     * @param e 终止索引</span>
<span class="cm">     */</span>
    <span class="n">SegmentTreeNode</span> <span class="o">*</span><span class="n">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">SegmentTreeNode</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SegmentTreeNode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span><span class="o">-&gt;</span><span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 中位</span>
            <span class="n">ret</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
            <span class="n">ret</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
            <span class="n">ret</span><span class="o">-&gt;</span><span class="n">sum</span> <span class="o">=</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">sum</span> <span class="o">+</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">SegmentTreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">)</span> <span class="c1">// 如果线段树只有一个数</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">sum</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 线段树中位</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// 左子树中更新，注意取等</span>
            <span class="k">else</span> <span class="nf">update</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// 右子树中更新</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">sum</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">sum</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span> <span class="c1">// 更新各层结点sum</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">sumRange</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">sumRange</span><span class="p">(</span><span class="n">SegmentTreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">==</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 线段树中位</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">)</span> <span class="k">return</span> <span class="n">sumRange</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 左子树中求和</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="k">return</span> <span class="n">sumRange</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 右子树中求和</span>
            <span class="k">else</span> <span class="k">return</span> <span class="nf">sumRange</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">sumRange</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// 树状数组</span>
<span class="k">class</span> <span class="nc">BinaryxexTree</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BinaryxexTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buildTree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">BinaryxexTree</span><span class="p">()</span> <span class="p">{};</span>

    <span class="kt">void</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">bit</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">getSum</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">getSum</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// i - 1 不会越出下界</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">getSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bit</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">NumArray</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="n">NumArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tree</span><span class="p">.</span><span class="n">buildTree</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tree</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">sumRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">.</span><span class="n">sumRange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">BinaryxexTree</span> <span class="n">tree</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<h4 id="_35">扫描线<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h4>
<h4 id="_36">线段树+扫描线<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 蓝桥杯 2017_10 线段树+扫描线 经典题</span>

<span class="c1">// https://blog.csdn.net/konghhhhh/article/details/78236036</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Line</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span> <span class="c1">//左右坐标，纵坐标（高度），f=1为入边，f=-1为出边</span>
    <span class="n">Line</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">Line</span><span class="p">(</span><span class="kt">int</span> <span class="n">_x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_f</span><span class="p">)</span> <span class="o">:</span> <span class="n">x1</span><span class="p">(</span><span class="n">_x1</span><span class="p">),</span> <span class="n">x2</span><span class="p">(</span><span class="n">_x2</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">_h</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">_f</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Line</span> <span class="o">&amp;</span><span class="n">l1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">SegTree</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pl</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 左端点编号，右端点编号，被覆盖次数，两个端点之间被覆盖的长度</span>
    <span class="n">SegTree</span> <span class="o">*</span><span class="n">lson</span><span class="p">,</span> <span class="o">*</span><span class="n">rson</span><span class="p">;</span>
    <span class="n">SegTree</span><span class="p">()</span> <span class="o">:</span> <span class="n">cnt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">ans</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">//记录所有的横坐标</span>
<span class="n">Line</span> <span class="n">lines</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="n">SegTree</span> <span class="o">*</span><span class="nf">buildTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">pl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SegTree</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SegTree</span><span class="p">();</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">pl</span> <span class="o">=</span> <span class="n">pl</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pl</span> <span class="o">==</span> <span class="n">pr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">((</span><span class="n">pl</span> <span class="o">+</span> <span class="n">pr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">lson</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">pl</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">rson</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">updateLength</span><span class="p">(</span><span class="n">SegTree</span> <span class="o">*</span><span class="n">pTree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pTree</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pTree</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">tr</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">tl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">//将区间树上的端点（序号）反入到X中求得二维坐标上的实际横坐标</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tl</span> <span class="o">==</span> <span class="n">tr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pTree</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">//负数</span>
        <span class="n">pTree</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">pTree</span><span class="o">-&gt;</span><span class="n">lson</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">pTree</span><span class="o">-&gt;</span><span class="n">rson</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">SegTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// 自底向上的更新cnt和len</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tl</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">pl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">pr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pl</span> <span class="o">&lt;=</span> <span class="n">tl</span> <span class="o">&amp;&amp;</span> <span class="n">pr</span> <span class="o">&gt;=</span> <span class="n">tr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">updateLength</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pl</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">update</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lson</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pr</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">update</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rson</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">updateLength</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y2</span><span class="p">);</span>
        <span class="n">X</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span>
        <span class="n">lines</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Line</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">X</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span>
        <span class="n">lines</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Line</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">lines</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
    <span class="c1">// 初始化线段树 先对index去重 然后得到X_end个不重复的横坐标值 所以共有X_end - 1 个离散的区间</span>
    <span class="kt">int</span> <span class="n">X_end</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span> <span class="o">+</span> <span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">;</span>
    <span class="n">SegTree</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">X_end</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pl</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span> <span class="o">+</span> <span class="n">X_end</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span> <span class="o">+</span> <span class="n">X_end</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x2</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="p">;</span>
        <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">f</span><span class="p">);</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">*</span> <span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">h</span> <span class="o">-</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">h</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_37">树状数组<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<blockquote>
<p><a href="https://blog.csdn.net/bestsort/article/details/80796531">https://blog.csdn.net/bestsort/article/details/80796531</a></p>
</blockquote>
<h2 id="_38">高精度<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h2>
<h3 id="_39">高精度进制转换<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 了解几个重要的 ASCII 码</span>
<span class="c1">// &#39;0&#39;: 48</span>
<span class="c1">// &#39;A&#39;: 65</span>
<span class="c1">// &#39;a&#39;: 97</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span> <span class="c1">// 转换过程中的十进制数</span>
<span class="kt">char</span> <span class="n">str1</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span> <span class="n">str2</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span> <span class="c1">// 源进制数与目标进制数</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// 源进制与目标进制</span>

<span class="kt">void</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// t[0] 是 t 最低位，str1[0] 是 str1 的最高位</span>
        <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span>                 <span class="c1">// str1[i] 是数字</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>              <span class="c1">// str1[i] 是大写字母 </span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>
        <span class="k">else</span>                                <span class="c1">// str1[i] 是小写字母 </span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span> <span class="o">-</span> <span class="mi">36</span><span class="p">);</span>
        <span class="n">t</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span><span class="p">;)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 从 t 高位开始</span>
            <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
            <span class="n">t</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">m</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">m</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="n">len</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 去掉高位的 0</span>
    <span class="p">}</span>

    <span class="n">str2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="p">{</span> <span class="c1">// str2[0] 是 str2 的最高位，循环从低位开始</span>
        <span class="kt">char</span> <span class="n">cur</span><span class="p">;</span> 
        <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">// 将以数字表示 </span>
            <span class="n">cur</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">)</span>  <span class="c1">// 将以大写字母表示</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
        <span class="k">else</span>  <span class="c1">// 将以小写字母表示 </span>
            <span class="n">cur</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">36</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
        <span class="n">str2</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">T</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">T</span><span class="p">;</span> 
    <span class="k">while</span> <span class="p">(</span><span class="n">T</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">str1</span><span class="p">;</span> <span class="c1">// 源进制，目标进制，源进制数字</span>
        <span class="n">solve</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">str1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">str2</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_40">大整数<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">bign</span> <span class="p">{</span> <span class="c1">// big number</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span> <span class="c1">// 存储大数，d[0]是最低位</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 记录长度</span>

    <span class="n">bign</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 构造方法</span>
        <span class="n">fill_n</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 这一步不可忽略！</span>
        <span class="c1">// fill_n 来自 #include&lt;algorithm&gt;</span>
        <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">bign</span> <span class="nf">change</span><span class="p">(</span><span class="kt">char</span> <span class="n">str</span><span class="p">[])</span> <span class="p">{</span> <span class="c1">// 整数转换为 bign</span>
    <span class="n">bign</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="c1">// bign 的长度即字符串的长度</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span> <span class="c1">// 注意，逆着赋值，str[0]是最高位</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="n">bign</span> <span class="n">a</span><span class="p">,</span> <span class="n">bign</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 从高位到低位比较</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 两数相等</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">bign</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">bign</span> <span class="n">add</span><span class="p">(</span><span class="n">bign</span> <span class="n">a</span><span class="p">,</span> <span class="n">bign</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 高精度 a + b</span>
        <span class="n">bign</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// c = a + b</span>
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 进位</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
            <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">carry</span><span class="p">)</span>
            <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">carry</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bign</span> <span class="n">sub</span><span class="p">(</span><span class="n">bign</span> <span class="n">a</span><span class="p">,</span> <span class="n">bign</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bign</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">.</span><span class="n">len</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 去除最高位的0，同时至少保留一位最低位</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bign</span> <span class="n">multi</span><span class="p">(</span><span class="n">bign</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bign</span> <span class="n">c</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 进位</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
            <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">carry</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">carry</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bign</span> <span class="n">divide</span><span class="p">(</span><span class="n">bign</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 返回商，r为余数</span>
        <span class="n">bign</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 从高位开始</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 加上上一位遗留的余数</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 该位不够除，为0</span>
            <span class="k">else</span> <span class="p">{</span> <span class="c1">// 够除</span>
                <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 商</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">.</span><span class="n">len</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 去除最高位的0，同时至少保留一位最低位</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table>
                
                  
                
              
              
                


  <h2 id="__comments">评论</h2>
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = "https://looperxx.github.io/My_wiki/Coding Knowledge/";
      this.page.identifier =
        "/Coding Knowledge/";
    };
    (function() {
      var d = document, s = d.createElement("script");
      s.src = "//https-looperxx-github-io-my-wiki.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>

              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../知识网络/" title="知识网络" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  后退
                </span>
                知识网络
              </span>
            </div>
          </a>
        
        
          <a href="../历年机试/" title="历年机试" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前进
                </span>
                历年机试
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2019 - 2020 Looper Xiao Xu
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/LooperXX" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://www.linkedin.com/in/%E5%95%B8-%E5%BE%90-012456163/" class="md-footer-social__link fa fa-linkedin"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.39abc4af.js"></script>
      
        
        
          
          <script src="../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../assets/javascripts/lunr/lunr.ja.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>